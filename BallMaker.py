import xml.etree.ElementTree as ET
import xml.dom.minidom
import jsbsim
import os
import shutil
import pandas as pd
import matplotlib.pyplot as plt
from czml import czml
import webbrowser
import pyproj
from scipy.optimize import minimize
import numpy as np
import datetime
from jinja2 import Environment, FileSystemLoader

def write_aircraft_file(aircraft_data_xml, path_data):

    # create header
    header_line_1 = '<?xml version="1.0"?>'
    header_line_2 = '<?xml-stylesheet type="text/xsl" href="http://jsbsim.sf.net/JSBSimScript.xsl"?>'

    # create a new XML file with the results
    string_data = header_line_1 + header_line_2 + ET.tostring(aircraft_data_xml, encoding="unicode", method='xml')

    # pretty print
    dom = xml.dom.minidom.parseString(string_data)

    # Write text to file
    my_file = open(path_data['aircraft']['absolute'], "w")
    my_file.write(dom.toprettyxml())
    my_file.close()


def add_fileheader_section(aircraft_data_xml):
    # Fileheader section
    fileheader_section = ET.SubElement(aircraft_data_xml, 'fileheader')
    author_subelement = ET.SubElement(fileheader_section, 'author')
    author_subelement.text = 'Nate Willis'

    # Return the appended xml
    return aircraft_data_xml


def add_metrics_section(aircraft_data_xml):

    # Metrics Section - Setup
    metrics_values = {
        'wingarea': {
            'unit': "FT2",
            'value': "1"
        },
        'wingspan': {
            'unit': "FT",
            'value': "1"
        },
        'chord': {
            'unit': "FT",
            'value': "1"
        },
        'htailarea': {
            'unit': "FT2",
            'value': "0"
        },
        'htailarm': {
            'unit': "FT",
            'value': "0"
        },
        'vtailarea': {
            'unit': "FT2",
            'value': "0"
        },
        'vtailarm': {
            'unit': "FT",
            'value': "0"
        }
    }

    # Metrics Section - Construction
    metrics_section = ET.SubElement(aircraft_data_xml, 'metrics')
    for metric_component in metrics_values:
        current_metric_dictionary = metrics_values[metric_component]
        current_metric_subsection = ET.SubElement(metrics_section, metric_component, {
            'unit': current_metric_dictionary['unit']
        })
        current_metric_subsection.text = current_metric_dictionary['value']

    metric_location = ET.SubElement(metrics_section, 'location', {'name': 'AERORP', 'unit': 'IN'})
    x_location = ET.SubElement(metric_location, 'x')
    x_location.text = '0'
    y_location = ET.SubElement(metric_location, 'y')
    y_location.text = '0'
    z_location = ET.SubElement(metric_location, 'z')
    z_location.text = '0'

    # Return completed section
    return aircraft_data_xml


def initialize_jsbsim_aircraft_xml(path_data):

    # create the file structure
    aircraft_data_xml = ET.Element('fdm_config', {
        'name': path_data['sim_name'],
        'version': '2.0',
        'release': 'BETA',
        'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance",
        'xsi:noNamespaceSchemaLocation': "http://jsbsim.sf.net/JSBSimScript.xsd"
    })
    comment = ET.Comment('Generated by Nate')
    aircraft_data_xml.append(comment)

    # Return initialized xml
    return aircraft_data_xml


def add_mass_balance_section(aircraft_data_xml):

    # Metrics Section - Setup
    mass_balance_values = {
        'ixx': {
            'unit': "SLUG*FT2",
            'value': "10"
        },
        'iyy': {
            'unit': "SLUG*FT2",
            'value': "10"
        },
        'izz': {
            'unit': "SLUG*FT2",
            'value': "10"
        },
        'ixy': {
            'unit': "SLUG*FT2",
            'value': "-0"
        },
        'ixz': {
            'unit': "SLUG*FT2",
            'value': "-0"
        },
        'iyz': {
            'unit': "SLUG*FT2",
            'value': "-0"
        },
        'emptywt': {
            'unit': "LBS",
            'value': "50"
        },
    }

    # Mass Balance section - Construction
    mass_balance_section = ET.SubElement(aircraft_data_xml, 'mass_balance')
    for mass_balance_component in mass_balance_values:
        current_mass_balance_dictionary = mass_balance_values[mass_balance_component]
        current_mass_balance_subsection = ET.SubElement(mass_balance_section, mass_balance_component, {
            'unit': current_mass_balance_dictionary['unit']
        })
        current_mass_balance_subsection.text = current_mass_balance_dictionary['value']

    cg_location = ET.SubElement(mass_balance_section, 'location', {'name': 'CG', 'unit': 'IN'})
    x_location = ET.SubElement(cg_location, 'x')
    x_location.text = '0'
    y_location = ET.SubElement(cg_location, 'y')
    y_location.text = '0'
    z_location = ET.SubElement(cg_location, 'z')
    z_location.text = '0'

    # Return the appended xml
    return aircraft_data_xml


def add_ground_reactions_section(aircraft_data_xml):

    # Contact Section - Setup
    contact_values = {
        'static_friction': {
            'unit': "",
            'value': "0"
        },
        'dynamic_friction': {
            'unit': "",
            'value': "0"
        },
        'rolling_friction': {
            'unit': "",
            'value': "0"
        },
        'spring_coeff': {
            'unit': "LBS/FT",
            'value': "10000"
        },
        'damping_coeff': {
            'unit': "LBS/FT/SEC",
            'value': "200000"
        },
        'max_steer': {
            'unit': "DEG",
            'value': "0.0"
        },
        'brake_group': {
            'unit': "",
            'value': "NONE"
        },
        'retractable': {
            'unit': "",
            'value': "0"
        },
    }

    # Ground reaction - Contacts
    ground_reactions_section = ET.SubElement(aircraft_data_xml, 'ground_reactions')
    contact_section = ET.SubElement(ground_reactions_section, 'contact', {'type': 'BOGEY', 'name': "NOSE_CONTACT"})

    # Contact Location
    contact_location = ET.SubElement(contact_section, 'location', {'unit': 'IN'})
    x_location = ET.SubElement(contact_location, 'x')
    x_location.text = '0'
    y_location = ET.SubElement(contact_location, 'y')
    y_location.text = '0'
    z_location = ET.SubElement(contact_location, 'z')
    z_location.text = '0'

    # Contact - Assembly
    for contact_component in contact_values:

        # Store dictionary for easy reference
        current_contact_dictionary = contact_values[contact_component]

        # Check if the unit is blank
        if current_contact_dictionary['unit'] == "":
            current_contact_attributes = {}
        else:
            current_contact_attributes = {'unit': current_contact_dictionary['unit']}

        # Write the subsection
        current_contact_subsection = ET.SubElement(contact_section, contact_component, current_contact_attributes)
        current_contact_subsection.text = current_contact_dictionary['value']

    # Return completed XML
    return aircraft_data_xml


def add_propulsion_section(aircraft_data_xml):

    # No propulsion currently
    propulsion_section = ET.SubElement(aircraft_data_xml, 'propulsion')

    # Return completed XML
    return aircraft_data_xml


def add_flight_control_section(aircraft_data_xml):

    # No flight control currently
    flight_control_section = ET.SubElement(aircraft_data_xml, 'flight_control', {'name': 'FGFCS'})

    # Return completed XML
    return aircraft_data_xml


def add_aerodynamics_section(aircraft_data_xml):

    # Create master subsection
    aerodynamics_section = ET.SubElement(aircraft_data_xml, 'aerodynamics')

    # Create Drag Subsection
    drag_axis_section = ET.SubElement(aerodynamics_section, 'axis', {'name': 'DRAG'})
    drag_section = ET.SubElement(drag_axis_section, 'function', {'name': 'aero/coefficient/CD'})
    description = ET.SubElement(drag_section, 'description')
    description.text = 'Drag'
    product = ET.SubElement(drag_section, 'product')
    aero_property = ET.SubElement(product, 'property')
    aero_property.text = 'aero/qbar-psf'
    area_property = ET.SubElement(product, 'property')
    area_property.text = 'metrics/Sw-sqft'
    value_property = ET.SubElement(product, 'value')
    value_property.text = '0.0001'

    # Return completed XML
    return aircraft_data_xml


def add_output_section(aircraft_data_xml, path_data):

    # Output Section - Setup
    output_values = {
        'property': 'gear/unit[0]/WOW',
        'rates': 'ON',
        'velocities': 'ON',
        'forces': 'ON',
        'moments': 'ON',
        'position': 'ON'
    }

    # Output section assembly
    output_section = ET.SubElement(aircraft_data_xml, 'output', {
        'name': path_data['output']['jsbsim_rel'], 'type': 'CSV', 'rate': '10'
    })
    for output_component in output_values:
        current_output_subsection = ET.SubElement(output_section, output_component)
        current_output_subsection.text = output_values[output_component]

    # Return XML
    return aircraft_data_xml


def create_aircraft_file(path_data):

    # Initialize
    data = initialize_jsbsim_aircraft_xml(path_data)

    # Fileheader
    data = add_fileheader_section(data)

    # Metrics
    data = add_metrics_section(data)

    # Mass Balance
    data = add_mass_balance_section(data)

    # Ground Reactions
    data = add_ground_reactions_section(data)

    # Propulsion
    data = add_propulsion_section(data)

    # Flight Control
    data = add_flight_control_section(data)

    # Add Aerodynamics
    data = add_aerodynamics_section(data)

    # Add Output
    data = add_output_section(data, path_data)

    # Write XML
    write_aircraft_file(data, path_data)


def initialize_jsbsim_init_file():

    # create the file structure
    init_xml = ET.Element('initialize', {'name': 'Cannonball example'})
    comment = ET.Comment('This file sets up a nate cannonball')
    init_xml.append(comment)

    # Return initialized xml
    return init_xml


def write_init_file(init_xml, path_data):

    # create header
    header_line_1 = '<?xml version="1.0"?>'

    # create a new XML file with the results
    string_data = header_line_1 + ET.tostring(init_xml, encoding="unicode", method='xml')

    # pretty print
    dom = xml.dom.minidom.parseString(string_data)

    # Write text to file
    my_file = open(path_data['init']['absolute'], "w")
    my_file.write(dom.toprettyxml())
    my_file.close()


def add_initialization_data(init_data, parameters):

    # Initialization Section - Setup
    init_values = {
        'ubody': {
            'unit': "FT/SEC",
            'value': str(parameters['initial_velocity_fps'])
        },
        'latitude': {
            'unit': "DEG",
            'value': str(parameters['launch_latitude'])
        },
        'longitude': {
            'unit': "DEG",
            'value': str(parameters['launch_longitude'])
        },
        'theta': {
            'unit': "DEG",
            'value': str(parameters['theta_degrees'])
        },
        'psi': {
            'unit': "DEG",
            'value': str(parameters['heading_degrees'])
        },
        'altitude': {
            'unit': "FT",
            'value': "1.0"
        },
    }

    # Construct XML
    for init_component in init_values:
        current_init_dictionary = init_values[init_component]
        current_init_subsection = ET.SubElement(init_data, init_component, {
            'unit': current_init_dictionary['unit']
        })
        current_init_subsection.text = current_init_dictionary['value']

    # Return xml
    return init_data


def create_init_file(path_data, u_parameters, s_parameters):

    # Merge parameters
    parameters = {**u_parameters, **s_parameters}

    # Initialize the init file
    data = initialize_jsbsim_init_file()

    # Add Init Data
    data = add_initialization_data(data, parameters)

    # Write XML
    write_init_file(data, path_data)


def initialize_jsbsim_script_xml(path_data):

    # create the file structure
    script_data_xml = ET.Element('runscript', {
        'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance",
        'xsi:noNamespaceSchemaLocation': "http://jsbsim.sf.net/JSBSimScript.xsd",
        'name': path_data['sim_name']
    })
    comment = ET.Comment('Generated by Nate')
    script_data_xml.append(comment)

    # Description
    description = ET.SubElement(script_data_xml, 'description')
    description.text = 'Automated Testing By Nate'

    # Aircraft Definition
    aircraft_element = ET.SubElement(script_data_xml, 'use', {
        'aircraft': path_data['sim_name'],
        'initialize': path_data['init']['name_without_extension']
    })

    # Return initialized xml
    return script_data_xml


def add_script_run_data(script_data_xml):

    # Master Run Element
    run_section = ET.SubElement(script_data_xml, 'run', {'start': '0.0', 'end': '10000', 'dt': '0.008333'})

    # End Simulation Event
    end_event_section = ET.SubElement(run_section, 'event', {'name': "Hit The Ground"})
    end_event_description = ET.SubElement(end_event_section, 'description')
    end_event_description.text = "When the cannonball hits the ground."
    end_event_condition = ET.SubElement(end_event_section, 'condition')
    end_event_condition.text = "gear/unit[0]/WOW eq 1"
    end_event_set = ET.SubElement(end_event_section, 'set', {'name': 'simulation/terminate', 'value': '1.0'})
    end_event_notify = ET.SubElement(end_event_section, 'notify')
    end_event_notify_property = ET.SubElement(end_event_notify, 'property')
    end_event_notify_property.text = "simulation/sim-time-sec"

    # Return xml
    return script_data_xml


def write_script_file(script_data_xml, path_data):

    # create header
    header_line_1 = '<?xml version="1.0"?>'
    header_line_2 = '<?xml-stylesheet type="text/xsl" href="http://jsbsim.sf.net/JSBSimScript.xsl"?>'

    # create a new XML file with the results
    string_data = header_line_1 + header_line_2 + ET.tostring(script_data_xml, encoding="unicode", method='xml')

    # pretty print
    dom = xml.dom.minidom.parseString(string_data)

    # Write text to file
    my_file = open(path_data['script']['absolute'], "w")
    my_file.write(dom.toprettyxml())
    my_file.close()


def create_script_file(path_data):

    # Initialize the init file
    data = initialize_jsbsim_script_xml(path_data)

    # Add Init Data
    data = add_script_run_data(data)

    # Write XML
    write_script_file(data, path_data)


def plot_csv_output(path_data):

    # Import CSV into pandas
    df = pd.read_csv(path_data['output']['absolute'])

    # Create Meter Column
    df['h-sl-meters'] = df['Altitude ASL (ft)'] / 3.28084

    # Create Array
    trajectory_list = []
    for index, rows in df.iterrows():
        trajectory_list.extend([rows['Time'], rows['Longitude (deg)'], rows['Latitude (deg)'], rows['h-sl-meters']])

    # Initialize czml document
    start_time = datetime.datetime.utcnow()
    max_sim_time = df['Time'].max()
    end_time = start_time + datetime.timedelta(seconds=max_sim_time)
    doc = czml.CZML()
    doc_packet = czml.CZMLPacket(
        id='document',
        version='1.0',
        #clock=czml.Clock(
        #    currentTime=start_time.isoformat(),
        #    multiplier=1,
        #    range='LOOP_STOP',
        #    step='SYSTEM_CLOCK_MULTIPLIER',
        #    startTime=start_time.isoformat(),
        #    stopTime=end_time.isoformat()
        #)
        )
    doc.packets.append(doc_packet)

    # Create Position
    trajectory_cartographic_position = czml.Position(
        cartographicDegrees=trajectory_list,
        epoch=datetime.datetime.now()
    )

    # Create Path
    path = czml.Path(show=True, width=1, leadTime=0, trailTime=3, resolution=5)

    # Create Ellipsoid
    ellipsoid = czml.Ellipsoid(show=True, radii=czml.Radii(cartesian=[1, 1, 1]))

    # Create Parent Packet
    trajectory_packet = czml.CZMLPacket(id='cannonball')
    trajectory_packet.path = path
    trajectory_packet.position = trajectory_cartographic_position
    trajectory_packet.ellipsoid = ellipsoid
    doc.packets.append(trajectory_packet)

    # Write the CZML document to a file
    doc.write(path_data['czml']['absolute'])

    # Write the HTML document to a file
    create_html_page(path_data, start_time, end_time)

    # Open document
    webbrowser.open("http://localhost:8000/" + path_data['html']['project_rel'])

    # Altitude ASL (ft) and Time
    fix, axs = plt.subplots(2)
    df.plot(x='Time', y='Altitude ASL (ft)', ax=axs[0])
    df.plot(x='Time', y='Theta (deg)', ax=axs[1])
    plt.show()


def run_configured_simulation(path_data):

    # Run Simulation
    #print('FG Exec Startup\n' + '-' * 100)
    fdm = jsbsim.FGFDMExec(sim_path_data['temp_dir'], None)
    fdm.set_debug_level(0)

    #print('Loading Script ' + sim_path_data['script']['jsbsim_rel'] + '\n' + '-' * 100)
    fdm.load_script(sim_path_data['script']['jsbsim_rel'])

    #print('Running Initial Condition\n' + '-' * 100)
    fdm.run_ic()

    #print('Printing Sim Config\n' + '-' * 100)
    #fdm.print_simulation_configuration()

    #print('Running Sim\n' + '-' * 100)
    while fdm.run() and fdm.get_sim_time() <= 20000:
        pass


def set_initial_sim_parameters(parameters):

    # Calculate Distance
    geod = pyproj.Geod(ellps='WGS84')
    forward_azimuth, backward_azimuth, target_distance_meters = geod.inv(
        parameters['launch_longitude'],
        parameters['launch_latitude'],
        parameters['target_longitude'],
        parameters['target_latitude'],
    )

    # Calculate FPS for initial guess
    fps_guess = 12 * target_distance_meters ** .498

    # Setup initial guess
    guess_parameters = {
        'initial_velocity_fps': fps_guess,
        'heading_degrees': forward_azimuth,
        'theta_degrees': 25
    }

    # Return Guess
    return guess_parameters


def get_distance_error_from_output(path_data, parameters):

    # Import CSV into pandas
    df = pd.read_csv(path_data['output']['absolute'])

    # Calculate Distance
    geod = pyproj.Geod(ellps='WGS84')
    forward_azimuth, backward_azimuth, target_distance_meters = geod.inv(
        parameters['target_longitude'],
        parameters['target_latitude'],
        df['Longitude (deg)'].iloc[-1],
        df['Latitude (deg)'].iloc[-1]
    )

    return target_distance_meters


def distance_error_from_sim_parameters(dynamic_parameters, static_parameters, path_data):

    # Create sim init file
    create_init_file(path_data, static_parameters, dynamic_parameters)

    # Run Simulation
    run_configured_simulation(path_data)

    # Return Calculated Error
    return get_distance_error_from_output(path_data, static_parameters)


def distance_error_from_optimization_parameters(optimization_parameters, static_parameters, path_data):
    # This function serves as a wrapper to get it into the form that scikit needs to do optimization

    reconstructed_sim_parameters = {
        'initial_velocity_fps': optimization_parameters[0],
        'heading_degrees': optimization_parameters[1],
        'theta_degrees': optimization_parameters[2]
    }

    return distance_error_from_sim_parameters(reconstructed_sim_parameters, static_parameters, path_data)


def create_path_data(name):

    # File names
    aircraft_name = name
    script_name = name + '_script'
    init_name = name + '_init'
    output_name = name
    czml_name = name
    html_name = name
    temp_dir = os.path.join(os.getcwd(), 'temp')

    # Path Setup
    path_data = {
        'sim_name': sim_name,
        'temp_dir': temp_dir,
        'bing_key': os.path.join(os.getcwd(), 'bing_key.txt'),
        'template_dir': os.path.join(os.getcwd(), 'templates'),
        'aircraft': {
            'name': aircraft_name + '.xml',
            'name_without_extension': aircraft_name,
            'jsbsim_rel': os.path.join('aircraft', aircraft_name, aircraft_name + '.xml'),
            'absolute': os.path.join(temp_dir, 'aircraft', aircraft_name, aircraft_name + '.xml')
        },
        'init': {
            'name': init_name + '.xml',
            'name_without_extension': init_name,
            'jsbsim_rel': os.path.join('aircraft', aircraft_name, init_name + '.xml'),
            'absolute': os.path.join(temp_dir, 'aircraft', aircraft_name, init_name + '.xml')
        },
        'output': {
            'name': output_name + '.csv',
            'name_without_extension': output_name,
            'jsbsim_rel': output_name + '.csv',
            'absolute': os.path.join(temp_dir, output_name + '.csv')
        },
        'script': {
            'name': script_name + '.xml',
            'name_without_extension': script_name,
            'jsbsim_rel': os.path.join('scripts', script_name + '.xml'),
            'absolute': os.path.join(temp_dir, 'scripts', script_name + '.xml')
        },
        'czml': {
            'name': czml_name + '.czml',
            'name_without_extension': czml_name,
            'jsbsim_rel': czml_name + '.czml',
            'absolute': os.path.join(temp_dir, czml_name + '.czml')
        },
        'html': {
            'name': html_name + '.html',
            'name_without_extension': html_name,
            'jsbsim_rel': html_name + '.html',
            'absolute': os.path.join(temp_dir, html_name + '.html'),
            'project_rel':  os.path.join('temp', html_name + '.html')
        }
    }

    # Remove and re-add temp directory if it didn't get removed at the end of the last run
    if os.path.isdir(path_data['temp_dir']):
        shutil.rmtree(path_data['temp_dir'])
    os.makedirs(os.path.dirname(path_data['aircraft']['absolute']))
    os.makedirs(os.path.dirname(path_data['script']['absolute']))

    # Return assembled data
    return path_data


def create_html_page(path_data, start_time, stop_time):

    # Get Bing Key
    with open(path_data['bing_key'], 'r') as file:
        bing_key = file.read().replace('\n','').replace(' ','')

    # Setup jinja templating
    file_loader = FileSystemLoader(path_data['template_dir'])
    env = Environment(loader=file_loader)

    # Read in template
    template = env.get_template('cannon.html')

    # Output our file
    html_string = template.render(
        bing_key=bing_key,
        czml_name=path_data['czml']['jsbsim_rel'],
        start_time=start_time.isoformat()+'Z',
        stop_time=stop_time.isoformat()+'Z'
    )
    my_file = open(path_data['html']['absolute'], "w")
    my_file.write(html_string)
    my_file.close()


if __name__ == '__main__':

    optimize_flag = False

    # User Inputs
    sim_name = 'cannonball'
    user_parameters = {
        'launch_latitude': 41.266784,
        'launch_longitude': -96.068277,
        'launch_altitude': 0,
        'target_latitude': 41.261463,
        'target_longitude': -96.026390,
        'target_altitude': 0
    }

    # Create path data
    sim_path_data = create_path_data(sim_name)

    # Setup initial guess
    sim_parameters = set_initial_sim_parameters(user_parameters)

    # Create Aircraft File
    create_aircraft_file(sim_path_data)

    # Create sim script file
    create_script_file(sim_path_data)

    # Run Optimizer or Single Run
    if optimize_flag:

        optimization_array = np.array([
                              sim_parameters['initial_velocity_fps'],
                              sim_parameters['heading_degrees'],
                              sim_parameters['theta_degrees']
                          ])

        result = minimize(
            distance_error_from_optimization_parameters,
            optimization_array,
            (user_parameters, sim_path_data),
            method='Nelder-Mead'
        )

        print(result)

    else:

        # Just Run Once
        print(distance_error_from_sim_parameters(sim_parameters, user_parameters, sim_path_data))

    print('Plotting output\n' + '-' * 100)
    plot_csv_output(sim_path_data)


